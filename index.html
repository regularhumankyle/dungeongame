<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dungeon Crawl: Prototype v11.50</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=Press+Start+2P&display=swap');
        body { font-family: 'Inter', sans-serif; overscroll-behavior: none; user-select: none; touch-action: manipulation; }
        
        /* Map & Grid */
        #map-area { position: relative; width: 100%; height: 100%; transform-origin: center center; transition: transform 0.1s ease-out; }
        #map-container.grabbing { cursor: grabbing; }
        .map-card-container { position: absolute; background-color: #1f2937; border: none; box-shadow: 0 4px 12px rgba(0,0,0,0.5); transition: all 0.3s ease; }
        
        /* Room Header Style */
        .card-header {
            position: absolute; top: -22px; left: 0; width: 100%; height: 22px;
            background-color: #111827; color: #9ca3af; font-size: 10px; font-weight: bold;
            text-transform: uppercase; display: flex; justify-content: center; align-items: center;
            border-top-left-radius: 4px; border-top-right-radius: 4px; z-index: 20;
            border: 1px solid #4b5563; border-bottom: none; padding: 0 4px;
            white-space: nowrap; overflow: hidden; text-overflow: ellipsis;
        }

        .map-card-container.locked-room { box-shadow: 0 0 0 2px #3b82f6; } 
        .map-card-container.boss-room { box-shadow: 0 0 0 2px #ef4444; } /* Red border for boss */

        .map-card-grid { display: grid; padding: 0; background-color: #4b5563; 
            grid-template-columns: repeat(3, 1fr); grid-template-rows: repeat(3, 1fr); width: 150px; height: 150px; 
        }

        .grid-space { width: 100%; height: 100%; border: 1px dotted #374151; display: flex; justify-content: center; align-items: center; position: relative; cursor: pointer; background-color: #9ca3af; font-size: 1.2rem; }
        
        /* Walls */
        .wall-top { border-top: 4px solid #000 !important; }
        .wall-bottom { border-bottom: 4px solid #000 !important; }
        .wall-left { border-left: 4px solid #000 !important; }
        .wall-right { border-right: 4px solid #000 !important; }
        
        .locked-door::after { content: 'üîí'; position: absolute; font-size: 1rem; z-index: 6; pointer-events: none; color: #1e3a8a; }
        .space-void { background-color: #1f2937; border: none; cursor: default; }

        /* Tokens */
        .token-marker {
            width: 24px; height: 24px; border-radius: 50%; 
            display: flex; justify-content: center; align-items: center; 
            font-size: 14px; font-weight: bold;
            box-shadow: 0 2px 4px rgba(0,0,0,0.5);
            position: absolute;
            background-color: #374151; color: white; border: 2px solid #d1d5db;
            transition: all 0.2s ease;
        }
        
        /* Boss Token Style (Printed on Card Look) */
        .token-boss {
            width: 40px; height: 40px; border-radius: 50%;
            background-color: #7f1d1d; border: 3px solid #ef4444;
            color: white; font-size: 20px; box-shadow: 0 0 15px rgba(239, 68, 68, 0.6);
            z-index: 5; /* Below player */
        }
        
        .token-monster { background-color: #991b1b; border-color: #ef4444; } 
        .token-loot    { background-color: #854d0e; border-color: #facc15; } 
        .token-event   { background-color: #581c87; border-color: #a855f7; }
        .token-key     { background-color: #1e3a8a; border-color: #3b82f6; } 
        .token-safe    { background-color: #fff; color: #000; border-color: #9ca3af; opacity: 0.5; } 
        .token-shop    { background-color: #064e3b; border-color: #22c55e; } 

        .player-token { width: 30px; height: 30px; border-radius: 50%; border: 2px solid white; box-shadow: 0 0 10px rgba(0,0,0,0.5); position: absolute; pointer-events: none; display:flex; justify-content:center; align-items:center; font-weight:bold; font-size: 12px; color: white; transition: all 0.2s ease; }
        .player-token.active { box-shadow: 0 0 15px 5px #fde047; z-index: 16; transform: scale(1.1); }
        .token-warrior { background-color: #ef4444; }
        .token-rogue { background-color: #374151; }
        .token-mage { background-color: #60a5fa; color: black; }
        .token-cleric { background-color: #fde047; color: black; }

        /* Setup Screen Cards */
        .class-card { background-color: #1f2937; padding: 1rem; border-radius: 0.5rem; border: 1px solid #4b5563; cursor: pointer; }
        .class-card.selected { border-color: #3b82f6; box-shadow: 0 0 0 2px #3b82f6; }

        .victory-card { background-color: #1f2937; padding: 1rem; border-radius: 0.5rem; border: 1px solid #4b5563; cursor: pointer; transition: all 0.2s; }
        .victory-card:hover { background-color: #374151; }
        .victory-card.selected { border-color: #10b981; box-shadow: 0 0 0 2px #10b981; background-color: #064e3b; }

        /* Deck Viewer Styles */
        .deck-grid { 
            display: grid; 
            grid-template-columns: repeat(auto-fill, minmax(140px, 1fr)); 
            gap: 1rem; 
            padding: 1rem;
            align-content: start; 
        }
        .deck-card { 
            background-color: #1f2937; 
            border: 1px solid #4b5563; 
            border-radius: 8px; 
            padding: 10px; 
            display: flex; 
            flex-direction: column; 
            align-items: center; 
            text-align: center;
            height: 180px;
            position: relative;
        }
        .deck-card h4 { font-weight: bold; font-size: 0.85rem; margin-bottom: 5px; color: #e5e7eb; height: 40px; display: flex; align-items: center; justify-content: center; width: 100%; overflow: hidden; }
        .deck-card p { font-size: 0.7rem; color: #9ca3af; overflow-y: auto; }
        .mini-map-grid { display: grid; grid-template-columns: repeat(3, 1fr); width: 60px; height: 60px; gap: 0; background: #374151; border: 1px solid #6b7280; margin-top: auto; margin-bottom: 10px; }
        .mini-cell { width: 100%; height: 100%; border: 1px dotted #4b5563; }
        .qty-badge {
            position: absolute; top: -5px; right: -5px;
            background-color: #2563eb; color: white;
            font-size: 0.7rem; font-weight: bold;
            padding: 2px 6px; border-radius: 999px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.5);
            border: 1px solid #60a5fa;
        }
        
        .dpad { display: grid; grid-template-columns: repeat(3, 1fr); gap: 0.5rem; width: 180px; margin: 0 auto; }
        .dpad-btn { background-color: #374151; border: 1px solid #4b5563; border-radius: 0.375rem; width: 60px; height: 60px; display: flex; justify-content: center; align-items: center; font-weight: bold; font-size: 1.5rem; color: white; }
        .dpad-btn:active { background-color: #1f2937; transform: scale(0.95); }

        /* Earthbound Style Combat Modal */
        .earthbound-bg {
            background: linear-gradient(45deg, #000000, #4a0e4e, #000000, #2c3e50);
            background-size: 400% 400%;
            animation: gradientBG 5s ease infinite;
        }
        @keyframes gradientBG {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }
        .eb-font { font-family: 'Press Start 2P', cursive; }
        .eb-box {
            background: black;
            border: 4px solid white;
            border-radius: 8px;
            padding: 16px;
            color: white;
        }
        
        .shake { animation: shake 0.5s; }
        @keyframes shake {
            0% { transform: translate(0, 0); }
            25% { transform: translate(-5px, 5px); }
            50% { transform: translate(5px, -5px); }
            75% { transform: translate(-5px, -5px); }
            100% { transform: translate(0, 0); }
        }

        /* Dice Visuals */
        .dice-tray { font-size: 2rem; color: #fbbf24; text-shadow: 2px 2px 0 #000; margin-bottom: 10px; display:flex; gap:10px; justify-content: center; }
        
        /* Debug Menu */
        .debug-overlay {
            position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9); border: 2px solid #ef4444; 
            color: white; padding: 20px; border-radius: 8px; z-index: 100;
            width: 80%; max-width: 600px;
            font-family: 'Courier New', monospace;
        }
        .debug-stat { display: flex; justify-content: space-between; border-bottom: 1px solid #333; padding: 4px 0; }
    </style>
</head>
<body class="bg-gray-900 text-gray-100 min-h-screen antialiased">
    <div id="app-container" class="p-4 md:p-8 max-w-full mx-auto lg:h-screen flex flex-col">
        <!-- Setup Screen -->
        <div id="setup-screen" class="h-full overflow-y-auto pb-32">
             <div class="flex justify-between items-center mb-4">
                 <h1 class="text-4xl font-bold text-white">Dungeon Crawl: v11.50</h1>
                 <button onclick="openDeckViewer()" class="bg-gray-700 hover:bg-gray-600 px-4 py-2 rounded text-white border border-gray-500 font-bold flex items-center gap-2">
                    üîç View Decks
                 </button>
             </div>
             
             <p id="init-error" class="text-red-500 font-bold hidden">Initialization Error! See Console.</p>

             <!-- Class Selection -->
             <h2 class="text-xl font-bold text-gray-300 mt-6 mb-2 border-b border-gray-700 pb-1">1. Select Party (1-4)</h2>
             <div id="class-selection-grid" class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-4 mb-8"></div>

             <!-- Victory Selection -->
             <h2 class="text-xl font-bold text-gray-300 mt-6 mb-2 border-b border-gray-700 pb-1">2. Select Victory Condition</h2>
             <div class="flex gap-6 mb-4 text-white">
                 <label class="flex items-center gap-2 cursor-pointer">
                     <input type="radio" name="difficulty" value="1" checked class="w-4 h-4 text-blue-600">
                     <span>Normal (Pick 1)</span>
                 </label>
                 <label class="flex items-center gap-2 cursor-pointer">
                     <input type="radio" name="difficulty" value="2" class="w-4 h-4 text-red-600">
                     <span>Hard (Pick 2)</span>
                 </label>
             </div>
             <div id="victory-selection-grid" class="grid grid-cols-1 gap-4 mb-8"></div>
             
             <div class="fixed bottom-0 left-0 w-full p-4 bg-gray-900 border-t border-gray-700">
                <button id="start-game-btn" class="w-full bg-blue-600 hover:bg-blue-700 text-white font-bold py-4 px-6 rounded-lg text-xl disabled:opacity-50 disabled:cursor-not-allowed" disabled>Start Game</button>
                <p id="setup-error-msg" class="text-center text-red-400 text-sm mt-2"></p>
             </div>
        </div>

        <!-- Game Screen -->
        <div id="game-screen" class="hidden flex flex-col lg:flex-row lg:h-[90vh] gap-8">
            <div class="flex-grow h-[60vh] lg:h-full flex flex-col">
                <div id="map-container" class="relative flex-grow w-full bg-black border-4 border-gray-700 rounded-lg overflow-hidden shadow-inner cursor-grab">
                    <div id="map-area"></div>
                </div>
            </div>
            <div class="flex-shrink-0 w-full lg:w-96 space-y-6 lg:h-full flex flex-col overflow-y-auto pb-20">
                 <!-- Victory Tracker -->
                 <div id="victory-tracker" class="bg-green-900 p-4 rounded shadow-lg border border-green-700 text-xs text-green-100">
                     <h3 class="font-bold uppercase mb-1">Current Objectives</h3>
                     <div id="victory-list"></div>
                 </div>

                 <div class="bg-gray-800 p-4 rounded shadow-lg border border-gray-700"><div id="player-stats-container"></div></div>
                 
                 <div class="bg-gray-800 p-4 rounded shadow-lg border border-gray-700">
                     <h3 class="text-lg font-bold text-gray-300 mb-2">Backpack</h3>
                     <div id="inventory-list" class="text-sm text-gray-400 italic">No items yet.</div>
                 </div>

                 <div class="bg-gray-800 p-4 rounded shadow-lg border border-gray-700">
                    <!-- Context Actions (Combats / Shops) -->
                    <div id="active-combat-actions" class="mb-4 hidden">
                        <!-- Populated dynamically -->
                    </div>

                    <p class="text-center mb-2 text-gray-300">Movement Points: <span id="mov-points" class="font-bold text-white">0</span></p>
                    <div class="dpad">
                         <button class="dpad-btn" data-dx="-1" data-dy="-1">‚Üñ</button><button class="dpad-btn" data-dx="0" data-dy="-1">‚Üë</button><button class="dpad-btn" data-dx="1" data-dy="-1">‚Üó</button>
                         <button class="dpad-btn" data-dx="-1" data-dy="0">‚Üê</button><button class="dpad-btn wait" data-dx="0" data-dy="0">WAIT</button><button class="dpad-btn" data-dx="1" data-dy="0">‚Üí</button>
                         <button class="dpad-btn" data-dx="-1" data-dy="1">‚Üô</button><button class="dpad-btn" data-dx="0" data-dy="1">‚Üì</button><button class="dpad-btn" data-dx="1" data-dy="1">‚Üò</button>
                    </div>
                    <button id="end-turn-btn" class="w-full mt-4 bg-yellow-600 text-black font-bold py-3 rounded-lg text-lg shadow-md active:scale-95 transition-transform">End Turn</button>
                 </div>
                 <div class="bg-gray-800 p-4 rounded flex-grow flex flex-col border border-gray-700 h-48 relative">
                     <h3 class="text-lg font-bold text-gray-400 mb-2">Log</h3>
                     <div id="game-log" class="flex-grow overflow-y-auto text-sm space-y-1 text-gray-300"></div>
                     <button onclick="toggleDebugMenu()" class="absolute top-2 right-2 text-xs bg-gray-700 text-red-400 px-2 py-1 rounded border border-red-900">Debug</button>
                 </div>
            </div>
        </div>
    </div>
    
    <!-- Debug Modal -->
    <div id="debug-menu" class="debug-overlay hidden">
        <div class="flex justify-between mb-4">
            <h2 class="text-xl font-bold text-red-500">Debug Menu</h2>
            <button onclick="toggleDebugMenu()" class="text-white">X</button>
        </div>
        <div id="debug-content" class="space-y-2"></div>
    </div>

    <!-- Standard Event Modal -->
    <div id="modal-backdrop" class="hidden fixed top-0 left-0 w-full h-full flex justify-center items-center z-50 bg-black bg-opacity-80 backdrop-blur-sm">
        <div id="event-modal" class="bg-gray-800 p-6 rounded-lg max-w-md w-full m-4 border border-gray-600 shadow-2xl">
            <h2 id="modal-title" class="text-2xl font-bold mb-2 text-yellow-400"></h2>
            <p id="modal-description" class="mb-6 text-gray-200"></p>
            <div id="modal-content" class="mb-4 text-sm text-gray-300"></div>
            <div id="modal-options" class="space-y-3 grid gap-2"></div>
            <button id="modal-close-btn" class="hidden mt-6 w-full bg-blue-600 hover:bg-blue-700 text-white font-bold py-3 px-4 rounded-lg">Continue</button>
        </div>
    </div>

    <!-- Deck Viewer Modal -->
    <div id="deck-viewer-backdrop" class="hidden fixed top-0 left-0 w-full h-full flex justify-center items-center z-50 bg-black bg-opacity-95 overflow-hidden">
        <div class="bg-gray-900 w-full h-full flex flex-col p-4 max-w-5xl mx-auto">
            <div class="flex justify-between items-center mb-4 border-b border-gray-700 pb-2">
                <h2 class="text-2xl font-bold text-white">Deck Inspector</h2>
                <button onclick="closeDeckViewer()" class="text-gray-400 hover:text-white text-2xl font-bold">&times;</button>
            </div>
            
            <!-- Category Tabs -->
            <div class="flex gap-2 mb-4 overflow-x-auto pb-2">
                <button class="deck-tab bg-blue-600 text-white px-4 py-2 rounded" onclick="renderDeckTab('items')">Items</button>
                <button class="deck-tab bg-gray-700 text-gray-300 px-4 py-2 rounded hover:bg-gray-600" onclick="renderDeckTab('monsters')">Monsters</button>
                <button class="deck-tab bg-gray-700 text-gray-300 px-4 py-2 rounded hover:bg-gray-600" onclick="renderDeckTab('classes')">Classes</button>
                <button class="deck-tab bg-gray-700 text-gray-300 px-4 py-2 rounded hover:bg-gray-600" onclick="renderDeckTab('events')">Events</button>
                <button class="deck-tab bg-gray-700 text-gray-300 px-4 py-2 rounded hover:bg-gray-600" onclick="renderDeckTab('rooms')">Rooms</button>
                <button class="deck-tab bg-gray-700 text-gray-300 px-4 py-2 rounded hover:bg-gray-600" onclick="renderDeckTab('corridors')">Corridors</button>
            </div>

            <!-- Grid Content -->
            <div id="deck-content" class="flex-grow overflow-y-auto deck-grid bg-gray-800 rounded border border-gray-700">
                <!-- Content Populated by JS -->
            </div>
        </div>
    </div>

    <!-- Combat Modal (Earthbound Style) -->
    <div id="combat-backdrop" class="hidden fixed top-0 left-0 w-full h-full flex justify-center items-center z-50 bg-black">
        <div class="earthbound-bg w-full h-full flex flex-col items-center justify-center p-4">
            
            <!-- Monster Area -->
            <div class="text-center mb-8">
                <div id="combat-monster-sprite" class="w-32 h-32 mx-auto bg-red-900 border-4 border-white mb-4 flex items-center justify-center text-4xl shadow-2xl animate-bounce">
                    üëπ
                </div>
                <h2 id="combat-monster-name" class="eb-font text-2xl text-white mb-2 text-shadow">Monster</h2>
                <div class="w-64 h-4 bg-gray-700 border-2 border-white mx-auto">
                    <div id="combat-monster-hp" class="h-full bg-green-500 transition-all duration-200" style="width: 100%"></div>
                </div>
                <p id="combat-monster-stats" class="mt-2 text-white font-bold text-xs"></p>
            </div>

            <!-- Message Area -->
            <div id="combat-log-area" class="eb-box w-full max-w-lg mb-8 h-28 overflow-y-auto text-sm">
                A wild monster appeared!
            </div>

            <!-- Player Area -->
            <div class="flex flex-col items-center w-full max-w-md">
                <div class="flex items-center gap-4 mb-4">
                    <div id="combat-player-token" class="w-16 h-16 rounded-full border-4 border-white bg-blue-600 flex items-center justify-center font-bold text-xl">P1</div>
                    <div class="eb-box flex-grow">
                        <p id="combat-player-name" class="font-bold text-yellow-400">Warrior</p>
                        <p id="combat-player-stats" class="text-xs">HP: 14/14</p>
                    </div>
                </div>
                
                <!-- Actions -->
                <div id="combat-actions" class="grid grid-cols-2 gap-4 w-full">
                    <button id="btn-attack" class="eb-box hover:bg-gray-800 text-center cursor-pointer font-bold">ATTACK</button>
                    <button id="btn-item" class="eb-box hover:bg-gray-800 text-center cursor-pointer font-bold">ITEM</button>
                    <button id="btn-run" class="eb-box hover:bg-gray-800 text-center cursor-pointer col-span-2 font-bold">RUN</button>
                </div>
                
                <button id="combat-continue-btn" class="hidden eb-box w-full mt-4 bg-blue-900 hover:bg-blue-800">CONTINUE</button>
            </div>
        </div>
    </div>

    <script>
        // --- GLOBAL STATE & HELPERS (Hoisted) ---
        
        const GAME_DATA = {
            classes: {
                "warrior": { id: "warrior", name: "Warrior", hp: 20, atk: 5, agi: 9, arm: 2, quantity: 1 },
                "rogue": { id: "rogue", name: "Rogue", hp: 16, atk: 6, agi: 13, arm: 0, quantity: 1 },
                "mage": { id: "mage", name: "Mage", hp: 12, atk: 7, agi: 11, arm: 0, quantity: 1 },
                "cleric": { id: "cleric", name: "Cleric", hp: 18, atk: 4, agi: 10, arm: 1, quantity: 1 }
            },
            victoryConditions: [
                { id: "boss", name: "Dragon's Hoard", desc: "Defeat the Final Boss" },
                { id: "wealth", name: "Wealthy Adventurers", desc: "Collect 50 pennies as a group" },
                { id: "items", name: "Legendary Heroes", desc: "Each player owns 1 item worth 6+ pennies" },
                { id: "exploration", name: "Dungeon Masters", desc: "Explore and clear 15 map cards" },
                { id: "kills", name: "Monster Slayers", desc: "Defeat 20 monsters as a group" }
            ],
            monsterDeck: [
                { name: "Goblin Warlord", atk: 4, agi: 10, arm: 0, hp: 12, sprite: "üë∫", quantity: 6 }, 
                { name: "Skeleton King", atk: 5, agi: 13, arm: 1, hp: 10, sprite: "üíÄ", quantity: 6 },  
                { name: "Orc Behemoth", atk: 6, agi: 8, arm: 2, hp: 22, sprite: "üëπ", quantity: 4 },   
                { name: "Giant Slime", atk: 3, agi: 6, arm: 0, hp: 25, sprite: "üíß", quantity: 4 },
                // Bosses
                { name: "Minotaur", atk: 7, agi: 11, arm: 2, hp: 35, sprite: "üêÇ", quantity: 1 },
                { name: "Red Dragon", atk: 9, agi: 14, arm: 4, hp: 60, sprite: "üêâ", quantity: 1 }    
            ],
            itemDeck: [
                { name: "Potion", cost: 5, desc: "Heal 5 HP", type: "active", quantity: 8 },
                { name: "Iron Sword", cost: 10, desc: "+1 ATK", type: "passive", quantity: 4 },
                { name: "Leather Armor", cost: 10, desc: "+2 Max HP", type: "passive", quantity: 4 }
            ],
            eventDeck: [
                { name: "Spike Trap", desc: "A hidden pit opens!", effect: "1 Damage", quantity: 5 },
                { name: "Poison Gas", desc: "A cloud of noxious fumes.", effect: "1 Damage", quantity: 5 },
                { name: "Falling Net", desc: "You are entangled.", effect: "Turn Ends", quantity: 5 },
                { name: "Tripwire", desc: "Watch your step!", effect: "1 Damage", quantity: 5 }
            ],
            mapCards: {
                "dungeonEntrance": { 
                    id: "dungeonEntrance", name: "Entrance", type: "room", locked: false, quantity: 1,
                    grid: [ 
                        { walls: ['top', 'left'] }, { walls: [] }, { walls: ['top', 'right'] }, 
                        { walls: [] }, { walls: [] }, { walls: [] }, 
                        { walls: ['bottom', 'left'] }, { walls: [] }, { walls: ['bottom', 'right'] } 
                    ] 
                },
                "room_crossroads": { 
                    id: "room_crossroads", name: "Crossroads Room", type: "room", locked: false, quantity: 10,
                    grid: [ 
                        { walls: ['top', 'left'] }, { walls: [] }, { walls: ['top', 'right'] }, 
                        { walls: [] }, { walls: [] }, { walls: [] }, 
                        { walls: ['bottom', 'left'] }, { walls: [] }, { walls: ['bottom', 'right'] } 
                    ] 
                },
                "room_great_hall": { 
                    id: "room_great_hall", name: "Great Hall", type: "room", locked: false, quantity: 10,
                    grid: [ 
                        { walls: ['top', 'left'] }, { walls: [] }, { walls: ['top', 'right'] }, 
                        { walls: [] }, { walls: [] }, { walls: [] }, 
                        { walls: ['bottom', 'left'] }, { walls: ['bottom'] }, { walls: ['bottom', 'right'] } 
                    ] 
                },
                "room_prison": { 
                    id: "room_prison", name: "Dungeon Prison", type: "room", locked: true, quantity: 5,
                    grid: [ 
                        { walls: ['top', 'left'] }, { walls: [] }, { walls: ['top', 'right'] }, 
                        { walls: ['left'] }, { walls: [] }, { walls: ['right'] }, 
                        { walls: ['bottom', 'left'] }, { walls: [] }, { walls: ['bottom', 'right'] } 
                    ] 
                },
                "room_vault": { 
                    id: "room_vault", name: "Treasure Vault", type: "room", locked: true, quantity: 5,
                    grid: [ 
                        { walls: ['top', 'left'] }, { walls: [] }, { walls: ['top', 'right'] }, 
                        { walls: ['left'] }, { walls: [] }, { walls: ['right'] }, 
                        { walls: ['bottom', 'left'] }, { walls: [] }, { walls: ['bottom', 'right'] } 
                    ] 
                },
                // BOSS ROOMS (Visually same as Vault but special ID)
                "room_mid_boss": { 
                    id: "room_mid_boss", name: "Lair of the Beast", type: "room", locked: true, quantity: 1,
                    grid: [ 
                        { walls: ['top', 'left'] }, { walls: [] }, { walls: ['top', 'right'] }, 
                        { walls: ['left'] }, { walls: [] }, { walls: ['right'] }, 
                        { walls: ['bottom', 'left'] }, { walls: [] }, { walls: ['bottom', 'right'] } 
                    ] 
                },
                "room_final_boss": { 
                    id: "room_final_boss", name: "Dragon's Keep", type: "room", locked: true, quantity: 1,
                    grid: [ 
                        { walls: ['top', 'left'] }, { walls: [] }, { walls: ['top', 'right'] }, 
                        { walls: ['left'] }, { walls: [] }, { walls: ['right'] }, 
                        { walls: ['bottom', 'left'] }, { walls: [] }, { walls: ['bottom', 'right'] } 
                    ] 
                }
            },
            corridors: {
                "hall_ns": { id: "hall_ns", name: "Hallway (NS)", type: "corridor", quantity: 5, grid: [{type:'void', walls:[]},{walls:['left','right']},{type:'void', walls:[]},{type:'void', walls:[]},{walls:['left','right']},{type:'void', walls:[]},{type:'void', walls:[]},{walls:['left','right']},{type:'void', walls:[]}] },
                "hall_ew": { id: "hall_ew", name: "Hallway (EW)", type: "corridor", quantity: 5, grid: [{type:'void', walls:[]},{type:'void', walls:[]},{type:'void', walls:[]},{walls:['top','bottom']},{walls:['top','bottom']},{walls:['top','bottom']},{type:'void', walls:[]},{type:'void', walls:[]},{type:'void', walls:[]}] },
                "corner_ne": { id: "corner_ne", name: "Corner (NE)", type: "corridor", quantity: 5, grid: [{type:'void', walls:[]},{walls:['top','left']},{type:'void', walls:[]},{type:'void', walls:[]},{walls:['bottom','right']},{walls:['top','bottom']},{type:'void', walls:[]},{type:'void', walls:[]},{type:'void', walls:[]}] }, 
                "corner_nw": { id: "corner_nw", name: "Corner (NW)", type: "corridor", quantity: 5, grid: [{type:'void', walls:[]},{walls:['top','right']},{type:'void', walls:[]},{walls:['top','bottom']},{walls:['bottom','left']},{type:'void', walls:[]},{type:'void', walls:[]},{type:'void', walls:[]},{type:'void', walls:[]}] }, 
                "corner_se": { id: "corner_se", name: "Corner", type: "corridor", quantity: 5, grid: [{type:'void', walls:[]},{type:'void', walls:[]},{type:'void', walls:[]},{walls:['left','top']},{walls:['bottom','right']},{type:'void', walls:[]},{type:'void', walls:[]},{walls:['left','right']},{type:'void', walls:[]}] },
                "corner_sw": { id: "corner_sw", name: "Corner (SW)", type: "corridor", quantity: 5, grid: [{type:'void', walls:[]},{type:'void', walls:[]},{type:'void', walls:[]},{walls:['top','bottom']},{walls:['top','right']},{type:'void', walls:[]},{type:'void', walls:[]},{walls:['left','right']},{type:'void', walls:[]}] },
                "t_north": { id: "t_north", name: "T-Junction (N)", type: "corridor", quantity: 5, grid: [{type:'void', walls:[]}, {type:'void', walls:[]}, {type:'void', walls:[]}, {walls:['top','bottom']}, {walls:['top']}, {walls:['top','bottom']}, {type:'void', walls:[]}, {walls:['left','right']}, {type:'void', walls:[]}] },
                "t_south": { id: "t_south", name: "T-Junction (S)", type: "corridor", quantity: 5, grid: [{type:'void', walls:[]}, {walls:['left','right']}, {type:'void', walls:[]}, {walls:['top','bottom']}, {walls:['bottom']}, {walls:['top','bottom']}, {type:'void', walls:[]}, {type:'void', walls:[]}, {type:'void', walls:[]} ] },
                "t_east": { id: "t_east", name: "T-Junction (E)", type: "corridor", quantity: 5, grid: [{type:'void', walls:[]}, {walls:['left','right']}, {type:'void', walls:[]}, {walls:['top','bottom']}, {walls:['right']}, {type:'void', walls:[]}, {type:'void', walls:[]}, {walls:['left','right']}, {type:'void', walls:[]}] },
                "t_west": { id: "t_west", name: "T-Junction (W)", type: "corridor", quantity: 5, grid: [{type:'void', walls:[]}, {walls:['left','right']}, {type:'void', walls:[]}, {type:'void', walls:[]}, {walls:['left']}, {walls:['top','bottom']}, {type:'void', walls:[]}, {walls:['left','right']}, {type:'void', walls:[]}] },
                "crossroads": { id: "crossroads", name: "Junction", type: "corridor", quantity: 5, grid: [{type:'void', walls:[]}, {walls:['left','right']}, {type:'void', walls:[]}, {walls:['top','bottom']}, {walls:[]}, {walls:['top','bottom']}, {type:'void', walls:[]}, {walls:['left','right']}, {type:'void', walls:[]}] }
            }
        };

        const CELL_SIZE = 50; 
        let gameState = {
            players: [], currentPlayerIndex: 0, mapLayout: {}, tokens: {}, 
            camera: { x: 0, y: 0, scale: 1.0 }, isPanning: false, panStart: { x: 0, y: 0 }, modalOpen: false,
            initialPinchDist: null, initialScale: 1.0,
            pendingTokenResolution: null, 
            combat: { active: false, monster: null, tokenKey: null, playerId: null },
            victory: { required: [], stats: { monstersKilled: 0, roomsCleared: 0, bossKilled: false } },
            decks: { rooms: [], corridors: [] },
            stats: { roomsPlaced: 0, totalRooms: 0 }
        };
        
        let selectedClasses = new Set();
        let selectedVictory = new Set();

        function pickRandom(arr) { return arr[Math.floor(Math.random() * arr.length)]; }
        function drawCard(deck) { return deck[Math.floor(Math.random() * deck.length)]; }
        
        function log(msg) {
            const l = document.getElementById('game-log');
            const d = document.createElement('div'); d.innerText = `> ${msg}`; l.prepend(d);
        }

        function combatLog(msg) {
            const area = document.getElementById('combat-log-area');
            const p = document.createElement('p');
            p.className = "mb-2";
            p.innerText = `> ${msg}`;
            area.prepend(p);
        }

        // --- DEBUG MENU ---
        function toggleDebugMenu() {
            const menu = document.getElementById('debug-menu');
            const content = document.getElementById('debug-content');
            if (menu.classList.contains('hidden')) {
                menu.classList.remove('hidden');
                
                // Safety Check for decks
                if (!gameState.decks.rooms || !gameState.decks.corridors) {
                    content.innerHTML = "Decks not initialized.";
                    return;
                }

                let totalRoomCards = 0;
                Object.values(GAME_DATA.mapCards).forEach(r => { if(r.id !== 'dungeonEntrance') totalRoomCards += (r.quantity||1); });
                
                const roomsLeft = gameState.decks.rooms.length;
                const corrLeft = gameState.decks.corridors.length;
                
                const midBossTarget = Math.floor(totalRoomCards / 2);
                const finalBossTarget = totalRoomCards;
                const currentRooms = gameState.stats.roomsPlaced;

                // Peek at next card logic (Safe access)
                const nextRoomName = roomsLeft > 0 ? gameState.decks.rooms[0].name : "None";

                const p = gameState.players[gameState.currentPlayerIndex];
                const coord = p ? `(${p.x}, ${p.y})` : "N/A";

                content.innerHTML = `
                    <div class="debug-stat"><span>Player Pos:</span> <span>${coord}</span></div>
                    <div class="debug-stat"><span>Rooms Placed:</span> <span>${currentRooms}</span></div>
                    <div class="debug-stat"><span>Room Deck:</span> <span>${roomsLeft} Left</span></div>
                    <div class="debug-stat"><span>Next Room:</span> <span class="text-yellow-400">${nextRoomName}</span></div>
                    <div class="debug-stat"><span>Corridor Deck:</span> <span>${corrLeft} Left</span></div>
                `;
            } else {
                menu.classList.add('hidden');
            }
        }

        // --- DECK VIEWER FUNCTIONS ---
        function openDeckViewer() { document.getElementById('deck-viewer-backdrop').classList.remove('hidden'); renderDeckTab('items'); }
        function closeDeckViewer() { document.getElementById('deck-viewer-backdrop').classList.add('hidden'); }

        function renderDeckTab(type) {
            const container = document.getElementById('deck-content');
            container.innerHTML = '';
            document.querySelectorAll('.deck-tab').forEach(btn => {
                if(btn.innerText.toLowerCase().includes(type)) {
                    btn.classList.remove('bg-gray-700', 'text-gray-300'); btn.classList.add('bg-blue-600', 'text-white');
                } else {
                    btn.classList.add('bg-gray-700', 'text-gray-300'); btn.classList.remove('bg-blue-600', 'text-white');
                }
            });

            if (type === 'items') {
                GAME_DATA.itemDeck.forEach(item => container.appendChild(createDeckCard(item.name, `${item.cost} Gold`, item.desc, item.quantity)));
            } else if (type === 'monsters') {
                GAME_DATA.monsterDeck.forEach(m => container.appendChild(createDeckCard(m.name, m.sprite, `HP:${m.hp} ATK:${m.atk} AGI:${m.agi}`, m.quantity)));
            } else if (type === 'classes') {
                Object.values(GAME_DATA.classes).forEach(c => container.appendChild(createDeckCard(c.name, "üë§", `HP:${c.hp} ATK:${c.atk} AGI:${c.agi}`, c.quantity || 1)));
            } else if (type === 'events') {
                GAME_DATA.eventDeck.forEach(e => container.appendChild(createDeckCard(e.name, "‚ö°", `${e.desc} (${e.effect})`, e.quantity)));
            } else if (type === 'rooms') {
                Object.values(GAME_DATA.mapCards).forEach(room => {
                    const card = createDeckCard(room.name, "", room.locked ? "LOCKED" : "Standard", room.quantity);
                    card.appendChild(renderMiniMap(room)); container.appendChild(card);
                });
            } else if (type === 'corridors') {
                Object.values(GAME_DATA.corridors).forEach(corr => {
                    const card = createDeckCard(corr.name, "", "Path", corr.quantity);
                    card.appendChild(renderMiniMap(corr)); container.appendChild(card);
                });
            }
        }

        function createDeckCard(title, icon, subtitle, qty) {
            const div = document.createElement('div');
            div.className = 'deck-card';
            div.innerHTML = `<div class="qty-badge">x${qty}</div><h4>${title}</h4><div class="text-2xl mb-1">${icon}</div><p>${subtitle}</p>`;
            return div;
        }

        function renderMiniMap(cardData) {
            const grid = document.createElement('div');
            grid.className = 'mini-map-grid';
            cardData.grid.forEach(cell => {
                const div = document.createElement('div');
                div.className = 'mini-cell';
                if (cell.type === 'void') { div.style.backgroundColor = '#1f2937'; div.style.border = 'none'; } 
                else {
                    div.style.backgroundColor = '#9ca3af';
                    if (cell.walls.includes('top')) div.style.borderTop = '3px solid black';
                    if (cell.walls.includes('bottom')) div.style.borderBottom = '3px solid black';
                    if (cell.walls.includes('left')) div.style.borderLeft = '3px solid black';
                    if (cell.walls.includes('right')) div.style.borderRight = '3px solid black';
                }
                grid.appendChild(div);
            });
            return grid;
        }

        // --- SETUP & INIT ---
        function renderSetup() {
            try {
                const grid = document.getElementById('class-selection-grid');
                if (!grid) return;
                grid.innerHTML = ''; 

                Object.values(GAME_DATA.classes).forEach(cls => {
                    const el = document.createElement('div');
                    el.className = 'class-card bg-gray-800 p-4 rounded border border-gray-600 text-white';
                    el.innerHTML = `<h3 class="font-bold text-lg">${cls.name}</h3><p class="text-sm">HP: ${cls.hp} | ATK: ${cls.atk}</p><p class="text-xs text-gray-400">AGI: ${cls.agi} | ARM: ${cls.arm}</p>`;
                    el.onclick = () => {
                        if (selectedClasses.has(cls.id)) { selectedClasses.delete(cls.id); el.classList.remove('selected'); }
                        else if (selectedClasses.size < 4) { selectedClasses.add(cls.id); el.classList.add('selected'); }
                        updateStartButton(selectedClasses, selectedVictory);
                    };
                    grid.appendChild(el);
                });

                const vGrid = document.getElementById('victory-selection-grid');
                vGrid.innerHTML = '';
                GAME_DATA.victoryConditions.forEach(vc => {
                    const el = document.createElement('div');
                    el.className = 'victory-card text-white';
                    el.innerHTML = `<h3 class="font-bold text-yellow-400">${vc.name}</h3><p class="text-sm text-gray-300">${vc.desc}</p>`;
                    el.onclick = () => {
                        const difficulty = document.querySelector('input[name="difficulty"]:checked').value;
                        const limit = parseInt(difficulty);
                        if (selectedVictory.has(vc.id)) {
                             selectedVictory.delete(vc.id); el.classList.remove('selected');
                        } else {
                            if (selectedVictory.size >= limit) {
                                const first = selectedVictory.values().next().value;
                                selectedVictory.delete(first);
                                Array.from(vGrid.children).forEach(child => {
                                    if(child.innerText.includes(GAME_DATA.victoryConditions.find(v=>v.id===first).name)) child.classList.remove('selected');
                                });
                            }
                            selectedVictory.add(vc.id); el.classList.add('selected');
                        }
                        updateStartButton(selectedClasses, selectedVictory);
                    };
                    vGrid.appendChild(el);
                });

                document.querySelectorAll('input[name="difficulty"]').forEach(rad => {
                    rad.addEventListener('change', () => {
                         selectedVictory.clear();
                         document.querySelectorAll('.victory-card').forEach(c => c.classList.remove('selected'));
                         updateStartButton(selectedClasses, selectedVictory);
                    });
                });
            } catch(e) { console.error(e); document.getElementById('init-error').innerText = "Init Error: " + e.message; document.getElementById('init-error').classList.remove('hidden'); }
        }

        function updateStartButton() {
            const btn = document.getElementById('start-game-btn');
            const err = document.getElementById('setup-error-msg');
            const diff = parseInt(document.querySelector('input[name="difficulty"]:checked').value);
            
            let valid = true;
            let msg = "";
            if (selectedClasses.size === 0) { valid = false; msg = "Select at least 1 Class."; }
            else if (selectedVictory.size !== diff) { valid = false; msg = `Select exactly ${diff} Victory Condition(s).`; }
            
            btn.disabled = !valid;
            err.innerText = msg;
        }

        // --- DECK BUILDING (PHYSICAL STACK) ---
        function buildDecks() {
            // 1. Collect all standard rooms
            let roomPool = [];
            Object.values(GAME_DATA.mapCards).forEach(room => {
                if (room.id === 'dungeonEntrance' || room.id.includes('boss')) return; 
                const qty = room.quantity || 1;
                for(let i=0; i<qty; i++) roomPool.push(room);
            });

            // 2. Shuffle Standard Rooms
            for (let i = roomPool.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [roomPool[i], roomPool[j]] = [roomPool[j], roomPool[i]];
            }

            // 3. Insert Mid Boss in Middle
            const midIndex = Math.floor(roomPool.length / 2);
            roomPool.splice(midIndex, 0, GAME_DATA.mapCards.room_mid_boss);

            // 4. Append Final Boss at End
            roomPool.push(GAME_DATA.mapCards.room_final_boss);

            gameState.decks.rooms = roomPool;

            // 5. Build Corridor Deck (Shuffled)
            gameState.decks.corridors = [];
            Object.values(GAME_DATA.corridors).forEach(corr => {
                const qty = corr.quantity || 1;
                for(let i=0; i<qty; i++) gameState.decks.corridors.push(corr);
            });
            // Shuffle Corridors
             for (let i = gameState.decks.corridors.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [gameState.decks.corridors[i], gameState.decks.corridors[j]] = [gameState.decks.corridors[j], gameState.decks.corridors[i]];
            }

            // Calc total stats for debug
            gameState.stats.totalRooms = gameState.decks.rooms.length;
        }

        function startGame() {
            try {
                const ids = Array.from(selectedClasses);
                const vicIds = Array.from(selectedVictory);

                gameState.players = ids.map((id, i) => ({
                    id: `p${i+1}`, class: GAME_DATA.classes[id], 
                    hp: GAME_DATA.classes[id].hp, maxHp: GAME_DATA.classes[id].hp,
                    gold: 5, moves: 1, x: 1, y: 1, inventory: [], fledTokenKey: null 
                }));

                gameState.victory.required = vicIds;
                gameState.victory.stats = { monstersKilled: 0, roomsCleared: 0, bossKilled: false };
                gameState.mapLayout = {}; gameState.tokens = {};
                gameState.stats.roomsPlaced = 0;
                
                buildDecks(); 
                placeCard(GAME_DATA.mapCards.dungeonEntrance, 0, 0);

                gameState.currentPlayerIndex = 0;
                document.getElementById('setup-screen').classList.add('hidden');
                document.getElementById('game-screen').classList.remove('hidden');
                updateUI(); centerCameraOnPlayer(); log("Dungeon initialized.");
            } catch(e) {
                alert("Start Game Error: " + e.message);
                console.error(e);
            }
        }

        // --- GENERATION ---
        function attemptPlaceCard(gx, gy, entryDx, entryDy, type) {
            const gridX = Math.floor(gx / 3) * 3; const gridY = Math.floor(gy / 3) * 3;
            if (getCellAt(gridX+1, gridY+1)) return false; 
            
            if (type === 'room') {
                // DRAW FROM ORDERED DECK
                if (gameState.decks.rooms.length === 0) return false; // No more rooms
                
                const nextCard = gameState.decks.rooms[0]; // Peek
                const cell = nextCard.grid[(gy - gridY) * 3 + (gx - gridX)];
                
                // Check fit (Rooms are 4-way, so should fit, but check walls/overlap)
                if (cell && cell.type !== 'void' && !isWallBlocking(cell, entryDx, entryDy)) {
                    placeCard(nextCard, gridX, gridY);
                    gameState.decks.rooms.shift(); // Remove from deck
                    return true;
                }
                // If top card doesn't fit, player is blocked. Do NOT discard.
                return false; 
            } else {
                // CORRIDORS ARE RANDOM POOL (Shuffled)
                // We try to find one in the shuffled deck that fits
                for(let i=0; i<gameState.decks.corridors.length; i++) {
                    const c = gameState.decks.corridors[i];
                    const cell = c.grid[(gy - gridY) * 3 + (gx - gridX)];
                    if (cell && cell.type !== 'void' && !isWallBlocking(cell, entryDx, entryDy)) {
                        placeCard(c, gridX, gridY);
                        // Remove used corridor
                        gameState.decks.corridors.splice(i, 1); 
                        return true;
                    }
                }
            }
            return false;
        }

        function generateTokensForCard(cardData, gx, gy) {
            if (cardData.id === 'dungeonEntrance') return; 
            
            // If Boss Room, DO NOT generate standard tokens.
            if (cardData.id.includes('boss')) {
                // Boss Token Logic is handled in placeCard
                return; 
            }

            const availableSpots = [];
            cardData.grid.forEach((cell, i) => { if (cell && cell.type !== 'void') availableSpots.push(i); });
            
            for(let i=availableSpots.length-1; i>0; i--){
                const j = Math.floor(Math.random()*(i+1));
                [availableSpots[i], availableSpots[j]] = [availableSpots[j], availableSpots[i]];
            }
            
            let placedKey = false;

            availableSpots.forEach(idx => {
                const tx = gx + (idx % 3);
                const ty = gy + Math.floor(idx / 3);
                const lx = idx % 3; const ly = Math.floor(idx/3);
                const isEdge = (lx === 0 || lx === 2 || ly === 0 || ly === 2);
                
                let type = 'safe';
                let safeChance = isEdge ? 0.7 : 0.4; 

                if (cardData.locked && !placedKey && !isEdge) { type = 'key'; placedKey = true; }
                else {
                    const roll = Math.random();
                    if (roll < (1 - safeChance)) {
                        const dangerRoll = Math.random();
                        if (dangerRoll < 0.5) type = 'monster';      
                        else if (dangerRoll < 0.75) type = 'loot';    
                        else if (dangerRoll < 0.9) type = 'event';    
                        else type = 'shop';    
                    } else { type = 'safe'; }
                }
                if (cardData.locked && !placedKey && idx === availableSpots[availableSpots.length-1]) { type = 'key'; }

                gameState.tokens[`${tx},${ty}`] = { type: type, revealed: false, monsterData: null };
            });
        }

        // --- CORE GAMEPLAY ---
        function showModal(title, desc, content) {
            document.getElementById("modal-title").innerText = title;
            document.getElementById("modal-description").innerText = desc;
            document.getElementById("modal-content").innerHTML = content;
            document.getElementById("modal-options").innerHTML = "";
            document.getElementById("modal-close-btn").classList.remove("hidden");
            document.getElementById("modal-backdrop").classList.remove("hidden");
            gameState.modalOpen = true;
        }

        function getCellAt(gx, gy) {
            for(const key in gameState.mapLayout) {
                const card = gameState.mapLayout[key];
                if (gx >= card.x && gx < card.x + 3 && gy >= card.y && gy < card.y + 3) return card.grid[(gy - card.y) * 3 + (gx - card.x)];
            }
            return null;
        }
        function getCardAt(gx, gy) {
            for(const key in gameState.mapLayout) {
                const card = gameState.mapLayout[key];
                if (gx >= card.x && gx < card.x + 3 && gy >= card.y && gy < card.y + 3) return card;
            }
            return null;
        }
        function isWallBlocking(cell, dx, dy) {
            if (!cell) return false; 
            if (dy === -1 && cell.walls.includes('top')) return true;
            if (dy === 1 && cell.walls.includes('bottom')) return true;
            if (dx === -1 && cell.walls.includes('left')) return true;
            if (dx === 1 && cell.walls.includes('right')) return true;
            return false;
        }

        function placeCard(cardData, gx, gy) {
            const key = `${gx},${gy}`;
            const newCard = { ...cardData, x: gx, y: gy, isLocked: cardData.locked };
            gameState.mapLayout[key] = newCard;
            
            // Room Logic
            if (cardData.type === 'room') {
                gameState.stats.roomsPlaced++; // Track rooms placed
                
                // Boss Logic: Manually place token at center (Index 4: +1, +1 relative)
                if (cardData.id === 'room_mid_boss') {
                    const mData = { ...GAME_DATA.monsterDeck.find(m => m.name === 'Minotaur') };
                    mData.currentHp = mData.hp;
                    gameState.tokens[`${gx+1},${gy+1}`] = { type: 'monster', revealed: true, monsterData: mData };
                } 
                else if (cardData.id === 'room_final_boss') {
                    const mData = { ...GAME_DATA.monsterDeck.find(m => m.name === 'Red Dragon') };
                    mData.currentHp = mData.hp;
                    gameState.tokens[`${gx+1},${gy+1}`] = { type: 'monster', revealed: true, monsterData: mData };
                } 
                else {
                    generateTokensForCard(newCard, gx, gy);
                }
            }
        }

        function movePlayer(dx, dy) {
            if (gameState.modalOpen) return;
            const p = gameState.players[gameState.currentPlayerIndex];
            if (p.moves <= 0) return log("No moves left.");

            const tx = p.x + dx; const ty = p.y + dy;
            const currentCell = getCellAt(p.x, p.y);
            const currentCard = getCardAt(p.x, p.y);
            const targetCard = getCardAt(tx, ty);

            if (isWallBlocking(currentCell, dx, dy)) return log("Blocked by wall.");
            if (targetCard !== currentCard && currentCard && currentCard.isLocked) return log("Door is Locked! Find the Key/Boss.");
            if (!targetCard && currentCard && currentCard.isLocked) return log("Door is Locked! Find the Key/Boss.");

            if (!targetCard) {
                if (Math.abs(dx) + Math.abs(dy) > 1) return log("No diagonal exploration.");
                const typeToFind = (currentCard.type === 'room') ? 'corridor' : 'room';
                if (!attemptPlaceCard(tx, ty, -dx, -dy, typeToFind)) return log("Blocked: Cannot explore further this way.");
                if (typeToFind === 'room') gameState.victory.stats.roomsCleared++;
            } else {
                const tCell = getCellAt(tx, ty);
                if (!tCell || tCell.type === 'void') return log("No floor there.");
                if (isWallBlocking(tCell, -dx, -dy)) return log("Blocked by target wall.");
            }

            const oldCard = getCardAt(p.x, p.y);
            p.x = tx; p.y = ty; p.moves--;
            p.fledTokenKey = null;
            const newCard = getCardAt(tx, ty); 

            updateUI(); centerCameraOnPlayer();

            if (newCard && newCard !== oldCard && newCard.isLocked) {
                let msg = "The door slams shut behind you! Find the Key.";
                if (newCard.id.includes('boss')) msg = "The heavy doors seal shut. Only death unlocks them.";
                showModal("LOCKED ROOM!", `You entered ${newCard.name}.`, msg);
                gameState.pendingTokenResolution = { x: tx, y: ty };
                return;
            }

            const tokenKey = `${tx},${ty}`;
            const token = gameState.tokens[tokenKey];
            if (token) {
                token.revealed = true;
                updateUI();
                setTimeout(() => resolveToken(token, p, tokenKey), 200); 
            }
        }

        function resolveToken(token, p, key) {
            if (token.type === 'safe') {
                log("The room is quiet.");
                delete gameState.tokens[key];
                updateUI();
                return; 
            }
            if (token.type === 'monster') {
                if (!token.monsterData) {
                    token.monsterData = { ...drawCard(GAME_DATA.monsterDeck) };
                    token.monsterData.currentHp = token.monsterData.hp;
                }
                startCombat(token.monsterData, key, gameState.currentPlayerIndex);
                return;
            }

            gameState.pendingTokenRemoval = key; 
            const modalBtn = document.getElementById("modal-close-btn");
            const modalOpts = document.getElementById("modal-options");
            modalBtn.classList.remove("hidden");
            modalOpts.innerHTML = "";

            if (token.type === 'loot') {
                const isItem = Math.random() > 0.7;
                if (isItem) {
                     const item = drawCard(GAME_DATA.itemDeck);
                     p.inventory.push(item.name);
                     showModal("Loot!", "You found an item!", `You got: ${item.name}`);
                     checkVictory();
                } else {
                    p.gold += 5;
                    showModal("Loot!", "You found a pouch.", "You found 5 Pennies.");
                    checkVictory();
                }
            } else if (token.type === 'event') {
                const event = drawCard(GAME_DATA.eventDeck);
                if(event.effect.includes("Damage")) p.hp = Math.max(0, p.hp - 1);
                else if (event.effect.includes("Turn Ends")) p.moves = 0;
                showModal("Event Triggered!", event.name, `${event.desc} (${event.effect})`);
            } else if (token.type === 'key') {
                log("KEY FOUND!");
                const card = getCardAt(p.x, p.y);
                if (card && card.isLocked) {
                    card.isLocked = false; 
                    showModal("Key Found!", "The doors unlock.", "You may now exit this room.");
                } else {
                    showModal("Key Found", "It doesn't fit anything here.", "Kept for later.");
                }
            } else if (token.type === 'shop') {
                gameState.pendingTokenRemoval = null; 
                if (!token.shopItems) token.shopItems = [drawCard(GAME_DATA.itemDeck), drawCard(GAME_DATA.itemDeck)];
                showModal("Merchant", `You have ${p.gold} Pennies.`, "Buy something?");
                modalBtn.classList.add("hidden"); 
                token.shopItems.forEach(item => {
                    const btn = document.createElement('button');
                    btn.className = "w-full bg-gray-700 hover:bg-gray-600 p-3 rounded border border-gray-500 flex justify-between";
                    btn.innerHTML = `<span>${item.name} (${item.desc})</span> <span class="text-yellow-400">${item.cost}G</span>`;
                    btn.onclick = () => {
                        if(p.gold >= item.cost) {
                            p.gold -= item.cost; p.inventory.push(item.name); log(`Bought ${item.name}`);
                            updateUI(); document.getElementById('modal-backdrop').classList.add('hidden'); gameState.modalOpen = false;
                            checkVictory();
                        } else { alert("Not enough gold!"); }
                    };
                    modalOpts.appendChild(btn);
                });
                const leaveBtn = document.createElement('button');
                leaveBtn.className = "w-full bg-red-900 hover:bg-red-800 p-3 rounded mt-4";
                leaveBtn.innerText = "Leave Shop";
                leaveBtn.onclick = () => { document.getElementById('modal-backdrop').classList.add('hidden'); gameState.modalOpen = false; };
                modalOpts.appendChild(leaveBtn);
            }
            updateUI();
        }

        function endTurn() {
             gameState.currentPlayerIndex = (gameState.currentPlayerIndex + 1) % gameState.players.length;
             checkTurnStartEvents();
        }
        function checkTurnStartEvents() {
             const p = gameState.players[gameState.currentPlayerIndex];
             p.moves = 1; log(`Turn: ${p.class.name}`);
             updateUI(); centerCameraOnPlayer();
             const key = `${p.x},${p.y}`;
             const token = gameState.tokens[key];
             if (token && token.type === 'monster' && token.monsterData) {
                 if (p.fledTokenKey === key) { log(`You tread carefully around the ${token.monsterData.name}...`); p.fledTokenKey = null; }
                 else { setTimeout(() => startCombat(token.monsterData, key, gameState.currentPlayerIndex), 500); }
             }
        }
        function startCombat(m, k, pid) {
            gameState.combat = { active: true, monster: m, tokenKey: k, playerIndex: pid };
            document.getElementById('combat-backdrop').classList.remove('hidden');
            document.getElementById('combat-actions').classList.remove('hidden');
            document.getElementById('combat-continue-btn').classList.add('hidden');
            document.getElementById('game-log').innerHTML = ''; 
            updateCombatUI(); combatLog(`A ${m.name} draws near!`);
        }
        function updateCombatUI() {
            const m = gameState.combat.monster; const p = gameState.players[gameState.combat.playerIndex];
            document.getElementById('combat-monster-name').innerText = m.name;
            document.getElementById('combat-monster-sprite').innerText = m.sprite;
            const hpPct = Math.max(0, (m.currentHp / m.hp) * 100);
            document.getElementById('combat-monster-hp').style.width = `${hpPct}%`;
            const displayHp = Math.max(0, m.currentHp);
            document.getElementById('combat-monster-stats').innerText = `HP: ${displayHp}/${m.hp} | AGI: ${m.agi} | ARM: ${m.arm}`;
            const tokenEl = document.getElementById('combat-player-token');
            tokenEl.className = `w-16 h-16 rounded-full border-4 border-white flex items-center justify-center font-bold text-xl token-${p.class.id}`;
            tokenEl.innerText = `P${gameState.combat.playerIndex + 1}`;
            document.getElementById('combat-player-name').innerText = p.class.name;
            const hpEl = document.getElementById('combat-player-stats');
            if(hpEl) hpEl.innerText = `HP: ${p.hp}/${p.maxHp} | ATK: ${p.class.atk} | AGI: ${p.class.agi}`;
        }
        function runCombatRound(action) {
            const p = gameState.players[gameState.combat.playerIndex];
            const m = gameState.combat.monster;
            document.getElementById('combat-actions').classList.add('hidden');
            
            if (action === 'attack') {
                let atk = p.class.atk; if(p.inventory.includes("Iron Sword")) atk++;
                const roll = Math.floor(Math.random()*6)+1 + Math.floor(Math.random()*6)+1;
                combatLog(`Rolled ${roll} + ATK ${atk} = ${roll+atk}`);
                if(roll+atk >= m.agi) {
                    const dmg = Math.max(1, atk - m.arm);
                    m.currentHp -= dmg;
                    combatLog(`HIT! ${dmg} damage.`);
                } else combatLog("MISS!");
            } else if (action === 'item') { 
                const idx = p.inventory.indexOf("Potion");
                if (idx > -1) {
                    p.inventory.splice(idx, 1);
                    const heal = 5;
                    p.hp = Math.min(p.maxHp, p.hp + heal);
                    combatLog(`You drank a potion. Recovered ${heal} HP.`);
                }
            }

            updateCombatUI();
            if(m.currentHp <= 0) { setTimeout(() => { combatLog("VICTORY!"); document.getElementById('combat-continue-btn').classList.remove('hidden'); }, 1000); return; }
            
            setTimeout(() => {
                const roll = Math.floor(Math.random()*6)+1 + Math.floor(Math.random()*6)+1;
                if(roll+m.atk >= p.class.agi) {
                    const dmg = Math.max(1, m.atk - p.class.arm);
                    p.hp -= dmg;
                    combatLog(`${m.name} hits for ${dmg}!`);
                } else combatLog(`${m.name} missed!`);
                updateCombatUI();
                if(p.hp <= 0) { combatLog("Collapsed..."); setTimeout(endCombatRound, 2000); }
                else setTimeout(endCombatRound, 1000);
            }, 1000);
        }
        function endCombatRound() {
            const m = gameState.combat.monster;
            if (m.currentHp <= 0) {
                delete gameState.tokens[gameState.combat.tokenKey];
                gameState.players[gameState.combat.playerIndex].gold += 2;
                gameState.victory.stats.monstersKilled++;
                
                // BOSS DEFEATED LOGIC
                if (m.name === 'Red Dragon') gameState.victory.stats.bossKilled = true;
                
                // Unlock Room if Boss
                const tRoom = getCardAt(gameState.players[gameState.combat.playerIndex].x, gameState.players[gameState.combat.playerIndex].y);
                if (tRoom && tRoom.id.includes('boss')) {
                     tRoom.isLocked = false;
                     log("The Boss is slain. The doors unlock!");
                }
                
                checkVictory();
            } else gameState.tokens[gameState.combat.tokenKey].monsterData = m;
            gameState.combat.active = false;
            document.getElementById('combat-backdrop').classList.add('hidden');
            updateUI(); endTurn();
        }
        
        function checkVictory() {
             let won = true;
             const stats = gameState.victory.stats;
             const players = gameState.players;
             
             const totalGold = players.reduce((acc, p) => acc + p.gold, 0);
             const legendaryCount = players.filter(p => p.inventory.includes("Iron Sword") || p.inventory.includes("Leather Armor")).length;

             gameState.victory.required.forEach(req => {
                  if (req === 'wealth' && totalGold < 50) won = false;
                  if (req === 'items' && legendaryCount < players.length) won = false;
                  if (req === 'exploration' && stats.roomsCleared < 15) won = false;
                  if (req === 'kills' && stats.monstersKilled < 20) won = false;
                  if (req === 'boss' && !stats.bossKilled) won = false;
             });

             if (won) {
                 showModal("GAME WON!", "Congratulations!", "You have completed your quest objectives.");
                 document.getElementById('modal-close-btn').innerText = "Play Again";
                 document.getElementById('modal-close-btn').onclick = () => location.reload();
             }
             
             const tracker = document.getElementById('victory-list');
             tracker.innerHTML = '';
             gameState.victory.required.forEach(reqId => {
                const cond = GAME_DATA.victoryConditions.find(c => c.id === reqId);
                let status = "0";
                let target = "?";
                
                if (reqId === 'kills') { status = gameState.victory.stats.monstersKilled; target = 20; }
                if (reqId === 'exploration') { status = gameState.victory.stats.roomsCleared; target = 15; }
                if (reqId === 'wealth') { status = totalGold; target = 50; }
                if (reqId === 'items') { status = legendaryCount; target = players.length; }
                if (reqId === 'boss') { status = gameState.victory.stats.bossKilled ? "1" : "0"; target = "1"; }
                
                const p = document.createElement('p');
                p.innerText = `- ${cond.name}: ${status}/${target}`;
                tracker.appendChild(p);
            });
        }
        function centerCameraOnPlayer() {
            const p = gameState.players[gameState.currentPlayerIndex];
            const container = document.getElementById('map-container');
            const tx = (p.x * CELL_SIZE) + (CELL_SIZE/2); const ty = (p.y * CELL_SIZE) + (CELL_SIZE/2);
            gameState.camera.x = -tx + (container.clientWidth/2); gameState.camera.y = -ty + (container.clientHeight/2);
            updateCamera();
        }
        function updateCamera() {
            document.getElementById('map-area').style.transform = `translate(${gameState.camera.x}px, ${gameState.camera.y}px) scale(${gameState.camera.scale})`;
        }

        // --- FINAL INITIALIZATION ---
        document.addEventListener('DOMContentLoaded', () => {
            renderSetup();
            const mapContainer = document.getElementById('map-container');

            mapContainer.addEventListener('wheel', (e) => {
                e.preventDefault();
                const scaleAmount = -e.deltaY * 0.001;
                gameState.camera.scale = Math.min(Math.max(0.5, gameState.camera.scale + scaleAmount), 3.0);
                updateCamera();
            }, { passive: false });
            
            const getDistance = (touches) => Math.hypot(touches[0].pageX - touches[1].pageX, touches[0].pageY - touches[1].pageY);
            const handleStart = (e) => {
                if (e.touches && e.touches.length === 2) {
                    gameState.isPanning = false; gameState.initialPinchDist = getDistance(e.touches); gameState.initialScale = gameState.camera.scale; return;
                }
                if (e.target.closest('.grid-space') || e.target.closest('.player-token') || e.target.closest('.token-marker')) return;
                gameState.isPanning = true;
                const cx = e.touches ? e.touches[0].clientX : e.clientX;
                const cy = e.touches ? e.touches[0].clientY : e.clientY;
                gameState.panStart = { x: cx - gameState.camera.x, y: cy - gameState.camera.y };
                mapContainer.classList.add('grabbing');
            };
            const handleMove = (e) => {
                if (e.touches && e.touches.length === 2 && gameState.initialPinchDist) {
                    e.preventDefault();
                    const currentDist = getDistance(e.touches);
                    gameState.camera.scale = Math.min(Math.max(0.5, gameState.initialScale * (currentDist / gameState.initialPinchDist)), 3.0);
                    updateCamera(); return;
                }
                if (!gameState.isPanning) return;
                e.preventDefault();
                const cx = e.touches ? e.touches[0].clientX : e.clientX;
                const cy = e.touches ? e.touches[0].clientY : e.clientY;
                gameState.camera.x = cx - gameState.panStart.x;
                gameState.camera.y = cy - gameState.panStart.y;
                updateCamera();
            };
            const handleEnd = (e) => { gameState.isPanning = false; mapContainer.classList.remove('grabbing'); if (e.touches && e.touches.length < 2) gameState.initialPinchDist = null; };

            mapContainer.addEventListener('mousedown', handleStart); window.addEventListener('mousemove', handleMove); window.addEventListener('mouseup', handleEnd);
            mapContainer.addEventListener('touchstart', handleStart, {passive: false}); window.addEventListener('touchmove', handleMove, {passive: false}); window.addEventListener('touchend', handleEnd);
            
            document.querySelectorAll('.dpad-btn').forEach(btn => btn.addEventListener('click', () => {
                const dx = parseInt(btn.dataset.dx); const dy = parseInt(btn.dataset.dy);
                if(dx===0 && dy===0) log("Waiting..."); else movePlayer(dx, dy);
            }));
            document.getElementById('end-turn-btn').addEventListener('click', endTurn);
            document.getElementById('start-game-btn').addEventListener('click', startGame);
            document.getElementById('modal-close-btn').addEventListener('click', () => {
                document.getElementById('modal-backdrop').classList.add('hidden'); gameState.modalOpen = false;
                
                if(gameState.pendingTokenResolution) {
                    const { x, y } = gameState.pendingTokenResolution;
                    gameState.pendingTokenResolution = null;
                    const key = `${x},${y}`;
                    const token = gameState.tokens[key];
                    if (token) {
                        token.revealed = true;
                        updateUI();
                        setTimeout(() => resolveToken(token, gameState.players[gameState.currentPlayerIndex], key), 200);
                    }
                }
                
                if(gameState.pendingTokenRemoval) {
                    delete gameState.tokens[gameState.pendingTokenRemoval];
                    gameState.pendingTokenRemoval = null;
                    updateUI();
                }
            });

            document.getElementById('btn-attack').addEventListener('click', () => runCombatRound('attack'));
            document.getElementById('btn-item').addEventListener('click', () => {
                const p = gameState.players[gameState.combat.playerIndex];
                const hasPotion = p.inventory.includes("Potion");
                if(hasPotion) runCombatRound('item');
                else combatLog("No usable items!");
            });
            document.getElementById('btn-run').addEventListener('click', () => {
                 combatLog("You ran away!");
                 const p = gameState.players[gameState.combat.playerIndex];
                 p.fledTokenKey = gameState.combat.tokenKey;
                 setTimeout(endCombatRound, 1000);
            });
            document.getElementById('combat-continue-btn').addEventListener('click', endCombatRound);
        });
    </script>
</body>
</html>
